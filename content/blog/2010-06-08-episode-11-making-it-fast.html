{% extends "_blog.html" %}

{% block file_metadata %}
<meta name="post_id" content="3344" />
<meta name="post_date" content="2010-06-08" />
<meta name="author_id" content="wilson.g" />
<meta name="title" content="Episode 11: Making It Fast" />
<meta name="category" content="lectures" />
<meta name="category" content="versions/version-4" />
{% endblock file_metadata %}

{% block content %}
<p><a href="{{root_path}}/4_0/invperc/tuning.html">Today's episode</a> is the last in the series on program design using invasion percolation as an example.  In it, we look at how to make the program we've developed so far run zillions of times faster. It's the longest episode so far, and probably the most difficult, but it makes two very important points:</p>
<ol>
<li>The biggest performance gains come from improvements to algorithms and data structures, not from tweaking loops and rearranging conditionals.</li>
<li>If you want to write a fast program, you should start by writing a simple one, test it, and then rewrite it piece by piece, re-testing as you go along.</li>
</ol>
<p>Here's the complete list of episodes:</p>
<ol>
<li><a href="{{root_path}}/4_0/invperc/intro.html">Introduction</a></li>
<li><a href="{{root_path}}/4_0/invperc/grid.html">The Grid</a></li>
<li><a href="{{root_path}}/4_0/invperc/aliasing.html">Aliasing</a></li>
<li><a href="{{root_path}}/4_0/invperc/random.html">Randomness</a></li>
<li><a href="{{root_path}}/4_0/invperc/neighbors.html">Finding Neighbors</a></li>
<li><a href="{{root_path}}/4_0/invperc/ties.html">Resolving Ties</a></li>
<li><a href="{{root_path}}/4_0/invperc/assembly.html">Assembling the Program</a></li>
<li><a href="{{root_path}}/4_0/invperc/bugs.html">Bugs</a></li>
<li><a href="{{root_path}}/4_0/invperc/refactoring.html">Refactoring</a></li>
<li><a href="{{root_path}}/4_0/invperc/test.html">Testing</a></li>
<li><a href="{{root_path}}/4_0/invperc/tuning.html"><strong><em>Tuning</em></strong></a></li>
</ol>
{% endblock content %}
